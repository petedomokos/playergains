
NEXT

 1. DONE  - sort the addRefs and removeRefs stuff for adding and removing players and datasets from groups - 
 just changed update method on group ctrl so it gets group first so it can compare exisitng players

 2a. DONE   -  work out why the deeper paths arent working for populate methods

 -------------------------------------------------

 2b. get the User profile page displaying the datasets that they are part of, via their groups. (we will do individual later)

 3.
 The user page will then also render a Dashboard child, whiuch will itself use withLoader 
 to load all the datasets fro that user fully, so that when user page loads, it displays a summary dashboard of just 
 that users data. impl this, except not the dashboard content.

 4. impl addDatasets measures property {name, unit, value} 
    - have raw and derived measures. eg raw = time, penalties   derived = score = time + penalties

 5. impl addDatapoints (note: no need to do targets diffeently - a target is just a datapoint with a future date)

 6. fix bugs and refactor everything to date.












incorect email or password error handling display - see logError func in CommonActions

implement PrivateRoutes so that they dont redirect to home but to referrer

incoproate Signup into store, sharing the action with createUser action. Its the same excepot the dialog at teh end should be diffrent 
(ie for a signed in user, it is 'create another' and 'return home', whereas for a non-signed in user, its just 'signin')

impl the sign up mesg into dialog for CreatUser, in both cases. do this by refactoring dialog state object into ...
dialog:{
    createUser:{
        open:false, mesg:''
    }
}


refactor asyncProcesses into an object that contains the response if required
eg for CreateGroup 
{status:creating}
then
{status:completed, error:?, group:? }
then
{status:undefined}

whereas for loading group, no need to store group here aswell as in the right place,so just
{status:loading}
then
{status:completed}
then
{status:undefined}
THEN I CAN IMPL THINGS LIKE 'GO TO GROUP' LINK IN DIALOG IN CREATEGROUP, AND 'GO TO USER' IN CREATEUSER


move auth stuff out of ui comps into cotainers (so containers deals with store and storage) - look online about best practice

CHECK ALL ROUTES AND AUTH ACTIONS - make aure only a user can edit or delete their account or groups

STORE QUESTIONS when signup, is the dialog initiated?


change asyncProcesses so it stores teh id of teh user or group that is loading.
that way, more than one user or group can be loaded simultaneously through multiple fetchUser calls
eg is if we are on User page of another user and page is refreshed - then first teh signedin user is loaded,
and currently the other User cannot start loading until signed in user returns,
becuase teh HOC withLoader looks to see if  loading =true. So need that loading flag to be false for that User.
ie multiple loading flags via use of ideg asyncProcesses = {loading.user._id = true}
BUT we also need to integrate with error (see below)

!!! HANDLE ERRORS - EG CreatUser and CreateGroup need to have different action buttons if not created
allowing them to fix error

//warning - username should be unique - needed fro CreateUser for example

for fetchUsers on the wserver side, we will filter them to only users who are 
connected to teh signedIn user. That means users who are in a group that teh signedInUser
is a memberOf or is admin for. (ie must be in user.administeredGroups.players
or user.groupsMemberOf.players) //in future, we will also add a following option
so any 2 players can choose top connect with each other and see each others profiles
and data

chain promises in create methods in user and group controllers, to go back into db and populate admin with username etc
instead of just sending back teh created user or group

Dialogs have an onClose prop - not sure what that is for - investigate eg see DeleteUser

Think thought how to handle that fact that the database could update from elsewhere during a session eg another user 
may change their name or delete. In that case, currently, loadUsers when called may bring the latest groups and administeredUsers,
but these would not override a deep user or group if I have previously loaded them.
One solution is a helper function eg groupHasUpdated, and call it in eg loadUsers.
current soln is to merge associated users and groups (with existing versions ) whenever a deep user or group is loaded 


Group addPlayers page - useEffect to remind user to save, and to reset


chnage groupsMemberOf to groups, and datasetsMemberOf to just datasets. so we have administeredGroups, and groups (same for datsets)


impl add/remove datasets from group - atm the Group page just shows all datasets. we want group admin to be able to edit, just like with players.
need to decide how best to handle datasetsMemberOf property in users. we dont want it getting overfilled every time a group asdmin adds another dataset.
But then again, we want a coach to be able to add a dataset to their groupo, and tehn when they go to the individual player page, they can see the dataset for that player,
rtaher than only being able to see it for the group.
So best soln is to keep user.groupsMemberOf fro only teh users benefit. And just when loading a user, we get groupsMemberOf, aso we can get groupsMemberOf.datasetsMemberOf for each group using 'populate' with a deep path

impl Delete/Edit Group/Dataset profiles


in SinmpleList, reduce secondary text to a max nr of chars, replace last  3 with ... and on hover reveal the full secondary text in a tooltip eg dataset.desc

on server addRef methods, they should only be added if they are unique. eg when adding players, we only want to 
add a groupRef if it doesnt exist yet. (we can tempoirarily filtering on client for now)

impl user being able to add datasets to themselves or to an administeredUser